%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%                                                                 %
%%%%%     <file_name>.tex                                             %
%%%%%                                                                 %
%%%%% Author:      <author>                                           %
%%%%% Created:     <date>                                             %
%%%%% Description: <description>                                      %
%%%%%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Preliminaries / Background}
\section{Hero}
\section{Halide Language}
	\subsection { Programing model}
		Halide is a functionnal programming language,  embedded into C++ designed to write high performance image and array processing code \cite{Web:Halide}. This language uses a functionnal paradigm to describe the functionnalities of the processing pipeline. The code of the algorithm is separated from how it will be implemented on the  target (schedule). 


		Every pipeline is a function (\verb|Halide::Func| composed of other functions and expressions (\verb|Halide:expr|). These two objects  use special variables (\verb|Halide:Vars|) to describe the operation executed on the array. The code snippet~\ref{code:simple_pipeline} 
		describe a basic pipeline which compute the distance of each coordinate of a two-dimentionnal array from on position specified by the vector \verb|(center_x, center_y)|.


\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true,tabsize=2}
\begin{lstlisting}[caption={Simple Pipeline Example}, captionpos=b, label={code:simple_pipeline}]
Halide::Var x, y;
Halide::Param center_x, center_y;
Halide::Expr offset = Halide::pow(x - center_x, 2) 
                      + Halide::pow(y - center_y, 2);

	gradient(x, y) = offset;
\end{lstlisting}
	This simple pipeline only has one stage, but it is possible to create multiple stage pipeline and transform it into a single stage inlined pipeline or keep it's multi stage structure, this operation will be done during the scheduling phase.

	After designing the  pipeline, we can define it's schedule via the different directive included in Halide. Halide implements all the basic scheduling option like parallelizing, unrolling the loops, splitting one loop into an inner and an outer loop... These options will be described in the section~\nameref{section:scheduling}. 

	In the example~\ref{code:simple_pipeline_schedule}, we can see how the scheduling works. All instructions are function of the pipeline object, and the final pipeline will implement these instructions. The example shows a simple schedule applied on our gradient, this schedule consists of parallelizing the execution over the x axis, and unrolling along the y axis.

	\begin{lstlisting}[caption={Simple Pipeline Example}, captionpos=b,label={code:simple_pipeline_schedule}];
	gradient.parallel(x);
	gradient.unroll(y, 10);
	\end{lstlisting}


	To execute the pipeline, Halide provides a large range of options, we can execute it directly using the \verb|.realize(x_max, y_max)| function, this is useful for debugging purpose, but most of the compile options are targeted at cross-compilation.
	
	As the initial goal of Halide was to target devices such as CPU, the library is capable of compiling the pipeline to a lot of different platform and output format. Halide support translation to C code, llvm assembly file, or already compiled object file specific to a given target(Cuda, Arm, Risc-V, MIPS, PowerPc...), and a given operating system( Linux, Mac, Windows, Android). The developer can also chose to compile the pipeline to a library to use in another application.

\subsection{Debugging Options}
	Halide has tools to debug the pipeline during it's compilation or when it is executed. First of all, the \verb|print()| and \verb|print_when()| functions can be called at any time in a pipeline and allow to print values of some variables. Another useful tool is the \verb|.trace_store()| function which prints the value every  functions evaluated in the pipeline. It is possible to get more informations during the compilation of the pipeline by setting the \verb|HL_DEBUG_CODEGEN| to 1, this will output the stages of the compilation and a pseudo code representation of the pipeline.
	Finally, variables and functions can have a label, which will be used by halide in it's internal representation, this function greatly reduce the debugging time of the schedules as Halide gives every variables a different name from the source code.


	\subsection {Basic Scheduling Options}
	\label{section:scheduling}

	Halide implement different scheduling instruction, and some of them just reshape the code in a different way. These scheduling instructions are useful to prepare the code for other instrutions (such as parallelization or vectorization), but also to  take advantage of memory locality.
	\subsubsection{Non Architecture Specific Instrutions}
	\begin{itemize}
		\item Reorder : Tells halide how to traverse the domain of the pipeline stage (ffor example in a column major or row major way)
		\item Split   : Split a dimension along inner and outer subdimensions.
		\item Tile    : Cut the domain in tiles.
		\item Fuse    : Join two dimensions in a single fused dimension.
		\item Unroll  : Unroll along one dimension.
	\end{itemize}
	These instructions are the basic one, but it is also possible to split the code in arbitrary areas which can have arbitrary shapes and sizes using reduction domains and the \verb|where()| instruction.

	Some of the primitives such as vectorize or parallel need to be implemented on the target platform as they take advantage of the specificities of the system. The halide Team doesn't prive a clear guide on how to port the language to a new platform, but using the header generated when building the pipeline, we can get enough information to implement enough functions to port halide to this new platform.

	\subsection { Porting Halide to new Platforms}
		First of all, to compile to a specific platform, we need a build of llvm which support the desired architecture.
		Then we can look in the pipeline header file to list all the vital functions for our pipeline. We can also use the error message when linking the pipeline to determine which functions we need to implement on the target platform. 
		Currently only the memory allocation functions, the print functions and the task distribution functions are implemented, and they are enough to  test basic pipelines such as matrix multiplications or light image modifications.
	After the implementation we can work on the compilation workflow for hero.

\section{Compilation Workflow}
	Every application has at least two source files, one C++ file which will generate the object file of the pipeline, the main application. 
	Currently, we can only compile the application to the hardware simulator.
	The compilation has two phases, during the first one, we compile the Halide application using llvm and run it on the host platform, this application will then generate an risc-V object file and a header.
	Then we compile the hero application using the already available Makefile, we include the header in the main application and the object file to the sources during the linking command.

		
\section{The full hero platform}
	The hardware platform has a more complex compiling process, currently the code is distributed to the \gls{pulp} thanks to OpenMp. The compilation first generate the llvm representation of the  code, then assign space on the device via \verb|hc-omp-space|, and also \verb|clang-offload-bundler| to distribute generate the llvm assembly code for the right platform. Finally the  program uses clang to compile the application, thanks to the special hero target, clang links every function correctly and then embed the riscV code inside the ARM application.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report_template"
%%% End: 
