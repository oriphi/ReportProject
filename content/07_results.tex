%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%                                                                 %
%%%%%     <file_name>.tex                                             %
%%%%%                                                                 %
%%%%% Author:      <author>                                           %
%%%%% Created:     <date>                                             %
%%%%% Description: <description>                                      %
%%%%%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Results}
\section{Test Setup}
	I benchmarked two applications on two platforms. I benchmarked the halide port  on the hardware simulation for the PULP cluste, and one openMp matrix multiplication application on the developpement platform on a Xilinx ZCU102. For the halide Application I generated random matrices, and for the openMp application I generated them using the same pattern every time. But as one multiplication takes two cycles every time, the execution time doesn't depend on the content of the matrices. The two matrices were stored in the L1 cache, to have the best access time we could, and to compare the code efficiency of both \gls{api}.
	To measure the number of cycles needed to run the application, I used two functions available in the hero sdk: \verb|hero_reset_clk_counter()| and \verb|hero_get_clk_counter()|. These functions resets and output the value of a counter incremented every cycle, as they only take less than twenty cycles to execute, they are useful to get cycles accurate measurements of the execution time of the function.
	With this setup, we can easily compare the performances of halide and OpenMp in a real world scenario for at least two basic schedules: Single threaded and Multi Threaded. I then experimented with different schedule with Halide to see the maximal performance I could get with this application.

	To give the results more meaning, I converted the benchmark data in operations per cycles where one operation can either be an addition a multiplication or a memory access (which take 2 cycles each), so for a matrix of size n, the number of operations to finish the multiplication is : $2 * n ** 3$.

\begin{figure}
	    \captionsetup{skip=1cm}
	\input{figures_raw/Roofline.pgf}
    \caption{A PGF histogram from \texttt{matplotlib}.}
\end{figure}

\begin{figure}
	    \captionsetup{skip=1cm}
        \input{figures_raw/Barplot.pgf}
    \caption{A PGF histogram from \texttt{matplotlib}.}
\end{figure}

\section{Comparaison between OpenMp and Halide on the different platforms}
