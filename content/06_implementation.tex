%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%                                                                 %
%%%%%     <file_name>.tex                                             %
%%%%%                                                                 %
%%%%% Author:      <author>                                           %
%%%%% Created:     <date>                                             %
%%%%% Description: <description>                                      %
%%%%%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Design Implementation}
	To test Halide, I used two applications. The first one was a basic gradient example~\ref{code:simple_pipeline}, and the second one a matrix multiplication pipeline that I took in the Halide repository and then adapted to be used in a hero application.
The matrix example is more interesting, as it represent what a typical signal processing application may do. It is also quite easy to benchmark with different sizes to see the impact of the memory access on the execution time.

\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true,tabsize=2}
\begin{lstlisting}[caption={Matrix Multiplication Pipeline}, captionpos=b, label={code:matmul_pipeline}]
    ImageParam A(type_of<int>(), 2);
    ImageParam B(type_of<int>(), 2);
    Var x, y;
    Func matrix_mul("matrix_mul");
    Func out;

    RDom k( 0,A.width() );

    matrix_mul(x, y) += A(x, k) * B(k, y);

    out(x, y) = matrix_mul(x, y);

\end{lstlisting}
	The Listing~\ref{code:matmul_pipeline} shows the full algorithm implementation. The code is straight forward and is pretty close to the mathematical expression of the operation.


	%% BETTER INTEGRATION

\section { Porting Halide to new Platforms}
	Halide is compiled using \gls{llvm}, as the \gls{hero} toolchain already has a build of this compiler, we can use it to compile Halide.

	 Some of the build options are incompatible with Halide, the \texttt{-DBUILD\_SHARED\_LIBS} flag has to be disabled, and \gls{llvm} also needs to support the x86 \gls{isa} to compile Halide for the build computer.

	%% BETTER INTEGRATION

	The library header file generated by Halide explains which functions needs to be implemented to make Halide work on our target platform.
	The error messages during the linking phase are also a good source of information to find which function are needed to compile the code. 
	Halide can now be built automatically using the \texttt{tc-halide}  target in the main \texttt{Makefile}.
	Once we added Halide to the toolchains, we can work on porting it to \gls{hero}.

	To make Halide work, we only need to port a small subset of functions. As most of the schedule are only reformatting the code.
	Only the parallel schedule has platform specific code. So we can make Halide work with these functions, the memory allocation primitives and the debugging functions (\texttt{halide\_printf}).

\section{Schedule Implementation }
	Most of the schedules implemented on halide does not require any platform specific implementation as they are working with loops, but we have to add the missing functions to the \gls{pulp} runtime.

	\subsection{Modification to the \acrshort{pulp} runtime}

	The missing halide functions needs to be accessible to the \gls{pulp} runtime, to do so, we created a new file in the kernel (\texttt{halide\_api.c}). 
	This file contains all the basic functions required to run halide on \gls{hero}, and the \glspl{atomicOp}.

	Currently, only the \texttt{parallel()} instruction needs a specific function: \texttt{halide\_do\_par\_for}.
	 This function initialise the \gls{pulp} cluster and add all the parallel tasks the cluster queue. These task executes \texttt{halide\_do\_par\_for\_fork} which is a wrapper around the pipeline function.
	Each core select which task it will run based on the task id, if the id of the task modulo the number of cores is equal to the core id, the task will be executed.

	Halide does not support the RISC-V \gls{simd} extension, but the vectorize schedule may still be used, as Halide will reshape the code as if it waas manipulating vectors.


 %%% WORK ON THE COMPILATION WORKFLOW

\section{Compilation Workflow}
	Every application has at least two source files, one C++ file which will generate the object file of the pipeline, the main application. 
	Currently, application can only be compiled for the hardware simulator.
	The compilation has two phases, during the first one, we compile the Halide application using \gls{llvm} and run it on the host platform, this application will then generate an RISC-V object file and a header.
	Then we compile the hero application using the same \texttt{Makefile} as the \gls{openmp} applications, but we also include the header in the main application and the object file to the sources during the linking command.


%\begin{figure}[tb]
%  \centering
%  \includegraphics[width=\linewidth]{./figures/tb}
%  \caption{Functional verification setup.}
%  \label{fig:func_ver}
%\end{figure}

